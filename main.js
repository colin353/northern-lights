// Generated by CoffeeScript 1.6.2
(function() {
  var Enemy, EnemyPrototype, GImage, GInputEvent, GMap, MapController, Prototype, ViewController, isMobileSafari, randomizeVector, simplifyPath, tick, vectorLength, viewcontroller, _ref,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Enemy = (function() {
    function Enemy(enemyprototype, path) {
      this.prototype = enemyprototype;
      this.path = simplifyPath(path);
      this.position = this.path[0];
    }

    Enemy.prototype.tick = function() {
      var displacement, length;

      console.log('Ticking enemy: ', this.position);
      document.viewcontroller.renderSprite(this.prototype.image, this.position.x, this.position.y, 1);
      displacement = {
        x: 0,
        y: 0
      };
      displacement.x = this.path[1].x - this.position.x;
      displacement.y = this.path[1].y - this.position.y;
      length = vectorLength(displacement);
      this.position.x += displacement.x / length;
      return this.position.y += displacement.y / length;
    };

    return Enemy;

  })();

  GImage = (function() {
    function GImage(location, owner) {
      var me;

      if (location == null) {
        location = 'broken.png';
      }
      this.image = new Image();
      this.image.src = "" + location;
      me = this;
      this.image.onload = function() {
        return me.onload.call(me);
      };
      this.loaded = false;
      this.owner = owner;
    }

    GImage.prototype.onload = function() {
      this.loaded = true;
      console.log('loaded image', this.image);
      if ((this.owner != null) && (this.owner.imageLoaded != null)) {
        return this.owner.imageLoaded();
      }
    };

    return GImage;

  })();

  GMap = (function() {
    function GMap(location) {
      var me;

      this.loaded = false;
      this.map = [];
      me = this;
      document.viewcontroller.loadImages("game/maps/" + location + ".png");
      this.image = "game/maps/" + location + ".png";
      this.background = document.viewcontroller.images["game/maps/" + location + ".png"];
      if (location != null) {
        $.get("game/maps/" + location + ".json", function(r) {
          me.loaded = true;
          return me.json = r;
        });
      } else {
        throw 'Invalid map supplied at gmap';
      }
    }

    return GMap;

  })();

  isMobileSafari = function() {
    return navigator.userAgent.match(/(iPod|iPhone|iPad)/) && navigator.userAgent.match(/AppleWebKit/);
  };

  randomizeVector = function(vector, offset) {
    var retval;

    retval = {
      x: 0,
      y: 0
    };
    retval.x = vector[0] + (2 * Math.random() - 1) * offset;
    retval.y = vector[1] + (2 * Math.random() - 1) * offset;
    return retval;
  };

  simplifyPath = function(path) {
    var p, retval, _i, _len;

    retval = [];
    for (_i = 0, _len = path.length; _i < _len; _i++) {
      p = path[_i];
      retval.push(randomizeVector(p.location, p.radius));
    }
    return retval;
  };

  vectorLength = function(v) {
    return Math.sqrt(v.x * v.x + v.y * v.y);
  };

  GInputEvent = (function() {
    function GInputEvent() {
      var data, type;

      type = arguments[0], data = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      this.type = type;
      switch (this.type) {
        case 'K':
          this.key = data[0];
          this.shift = data[1];
          break;
        case 'M':
        case 'MD':
          this.x = data[0];
          this.y = data[1];
          break;
        case 'D':
          this.dir = data[0];
      }
    }

    GInputEvent.prototype.toText = function() {
      var char, shift, textstring;

      textstring = '';
      switch (this.type) {
        case 'K':
          char = String.fromCharCode(this.key);
          shift = '';
          if ((this.shift != null) && this.shift) {
            shift = ' + SHIFT ';
          }
          textstring = "Keyboard event: key number " + this.key + " " + shift + " (which is '" + char + "')";
          break;
        case 'M':
          textstring = "Mouse click at (" + this.x + ", " + this.y + ")";
          break;
        case 'D':
          textstring = "D-pad cilcked (" + this.dir + ")";
          break;
        default:
          textstring = "Input type " + this.type;
      }
      return textstring;
    };

    return GInputEvent;

  })();

  MapController = (function() {
    function MapController(mapname) {
      this.relinquishcontrol = false;
      this.map = new GMap(mapname);
      this.enemies = [];
      this.count = 0;
      document.viewcontroller.map.push(this.map);
      this.rat = new EnemyPrototype('game/assets/enemies/rat.json');
      document.viewcontroller.prototypes.push(this.rat);
    }

    MapController.prototype.spawnEnemy = function(enemyprototype) {
      return this.enemies.push(new Enemy(this.rat, this.map.json.nodes));
    };

    MapController.prototype.tick = function() {
      var e, _i, _len, _ref;

      if (this.count === 0) {
        this.spawnEnemy(this.rat);
      }
      viewcontroller.renderSprite(this.map.image, 0, 0, 1);
      _ref = this.enemies;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        e = _ref[_i];
        e.tick.call(e);
      }
      return this.count++;
    };

    return MapController;

  })();

  Prototype = (function() {
    function Prototype(location) {
      var me;

      this.loaded = false;
      me = this;
      if (location != null) {
        $.get(location, function(r) {
          me.loaded = true;
          me.json = r;
          return me.didLoad.call(me);
        });
      } else {
        throw 'Invalid prototype supplied.';
      }
    }

    Prototype.prototype.didLoad = function() {
      return true;
    };

    return Prototype;

  })();

  EnemyPrototype = (function(_super) {
    __extends(EnemyPrototype, _super);

    function EnemyPrototype() {
      _ref = EnemyPrototype.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    EnemyPrototype.prototype.didLoad = function() {
      this.image = "game/images/" + this.json.image;
      return document.viewcontroller.loadImages(this.image);
    };

    return EnemyPrototype;

  })(Prototype);

  ViewController = (function() {
    function ViewController(selector) {
      var me;

      if (selector == null) {
        selector = "pokeCanvas";
      }
      this.canvas = $("#" + selector).get(0);
      this.context = this.canvas.getContext('2d');
      this.context.font = '45px "Courier"';
      if (isMobileSafari()) {
        this.context.font = '45px "Courier"';
      }
      this.images = [];
      this.prototypes = [];
      this.map = [];
      this.stack = [];
      this.timestep = 300;
      this.inputstack = [];
      this.dpad_touchstate = [];
      this.mousedown = false;
      this.mousepos = {
        x: 0,
        y: 0
      };
      me = this;
      $(document).mouseup(function(e) {
        return me.mousedown = false;
      });
      $(document).mousemove(function(e) {
        return me.mousepos = {
          x: e.pageX,
          y: e.pageY
        };
      });
      $(this.canvas).mousedown(function(e) {
        me.canvasinput_mouseClick(e.pageX, e.pageY);
        return me.mousedown = true;
      });
      $(document).keypress(function(e) {
        e.preventDefault();
        return me.inputstack.push(new GInputEvent('K', e.keyCode, e.shiftKey));
      });
    }

    ViewController.prototype.ready = function() {
      var a, b, _i, _j, _len, _len1, _ref1;

      _ref1 = [this.images, this.map, this.prototypes];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        a = _ref1[_i];
        for (_j = 0, _len1 = a.length; _j < _len1; _j++) {
          b = a[_j];
          if (((b.loaded != null) && !b.loaded) || ((b[a] != null) && ((b[a].loaded == null) || !b[a].loaded))) {
            return false;
          }
        }
      }
      return true;
    };

    ViewController.prototype.loadImages = function() {
      var a, list, _i, _len;

      list = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        a = list[_i];
        this.images[a] = new GImage(a, this);
      }
      return true;
    };

    ViewController.prototype.renderSprite = function(image, x, y, scale, flip) {
      var height, width;

      if (scale == null) {
        scale = 1;
      }
      if (flip == null) {
        flip = false;
      }
      width = this.images[image].image.width;
      height = this.images[image].image.height;
      this.context.save();
      if (flip === true) {
        this.context.translate(this.canvas.width / 2, 0);
        this.context.scale(-1, 1);
        this.context.translate(-this.canvas.width / 2, 0);
        x = this.canvas.width - x - width * scale;
      }
      this.context.drawImage(this.images[image].image, x, y, width * scale, height * scale);
      return this.context.restore();
    };

    ViewController.prototype.imageLoaded = function() {
      return true;
    };

    ViewController.prototype.canvasinput_mouseClick = function(x, y) {
      x = Math.floor(x - $(this.canvas).offset().left);
      y = Math.floor(y - $(this.canvas).offset().top);
      return this.inputstack.push(new GInputEvent('M', x, y));
    };

    ViewController.prototype.canvasinput_mouseDrag = function(x, y) {
      x = Math.floor(x - $(this.canvas).offset().left);
      y = Math.floor(y - $(this.canvas).offset().top);
      return this.inputstack.push(new GInputEvent('MD', x, y));
    };

    ViewController.prototype.tick = function() {
      if (!this.ready()) {
        return false;
      }
      if (this.mousedown === true) {
        this.canvasinput_mouseDrag(this.mousepos.x, this.mousepos.y);
      }
      this.stack[0].tick();
      this.inputstack = [];
      return true;
    };

    return ViewController;

  })();

  viewcontroller = new ViewController;

  document.viewcontroller = viewcontroller;

  viewcontroller.stack.push(new MapController('map-01'));

  tick = function() {
    viewcontroller.tick();
    return setTimeout(tick, viewcontroller.timestep);
  };

  tick();

}).call(this);
